# **Part 05** AOP라는 패러다임

## **Chapter 18** AOP라는 패러다임

 - AOP는 흔히 '관점(관심사) 지향 프로그래밍'으로 변역 된다.
- AOP가 추구하는 것은 '관심사의 분리'이다
 - 예로 나눗셈을 구현한다면
    - 두개 의 숫자 = '핵심로직'
    - 0을 나누는 것이 아닌지 등을 체크 = '주변로직'

 - 즉, '관심사'는 가장 중요한 로직은 아니지만, 사전 조건이나 사후 조건 등으로 간주한다.

 - AOP는 과거에 개발자가 작성했던 '관심사 + 비즈니스 로직'을 분리해서 별도의 코드로 작성하도록 하고, 실행 할 때 이를 결합하는 방식으로 접근한다.
    - 개발자가 작성한 코드와 분리된 관심사를 구현한 코드를 컴파일 혹은 실행 시점에 결합

- 실제 실행은 결합된 상태의 코드가 실행되기 때문에 개발자들은 핵심 비즈니스 로직에만 근거해서 코드를 작성하고, 나머지는 어떤 관심사들과 결합할 것인지를 설정하는 것 만으로 모든 개발을 마칠 수 있다.

- 스프링이 AOP를 지원한다는 것이 스프링의 가장 중요한 특징중에 하나로 말게된 이유 역시 별도의 복잡한 설정이나 제약 없이 스프링 내에서 간편하게 AOP의 기능들을 구현할 수 있기 떄문이다.
    - 작성된 모든 메서드의 실행 시간이 얼마인지를 기록하는 기능을 기존 코드의 수정 없이 작성가능
    - 잘못된 파라미터가 들어와서 예외가 발생하는 상황을 기존 코드의 수정 없이도 제어

### 18.1 AOP 용어

 - AOP는 기존의 코드를 수정하지 않고, 원하는 기능들과 결합할 수 있는 패러다임이다.

 <img src="../img/AOP_Picture.png"></br>
  
  - **Target**에 해당하는 것이 바로 개발자가 작성한 핵심 비즈니스 로직을 가지는 객체이다.
      - 순수한 비즈니스 로직을 의미하고, 어떠한 관심사들과도 관계를 맺지 않는다.
      - 순수한 코어라고 볼 수있다.
  - Target을 전체적으로 감싸고 있는것을 **Proxy**라고 한다.
      - 내부적으로 Target을 호출하지만, 중간에 필요한 관심사들을 거쳐서 Target을 호출하도록 자동 혹은 수동으로 작성된다.
      - Proxy의 존재는 직접 코드를 통해서 구현하는 경우도 있지만, 대부분의 경우 스프링 AOP 기능을 이용해서 자동으로 생성되는(auto-proxy)방식을 이용한다.
  - **JoinPoint**는 Target객체가 가진 메서드이다.
      - 외부에서의 호출은 Proxy객체를 통해 Target 객체의 JoinPoint를 호출하는 방식이라고 이해할 수 있다.

 <img src="../img/AOP_Picture2.png"></br>

  - Advice와 JoinPoint의 관계이다.
  - **JoinPoint**는 Target이 가진 여러 메서드라고 보면된다.(엄밀하게 스프링 AOP에서는 메서드만이 JoinPoint가 된다.)
  - Target에는 여러 메서드가 존재하기 때문에 어떤 메서드에 관심사를 결합할 것인지를 결정해야 하는데 이결정을 **'PointCut'** 이라고 한다.
  - **PointCut**은 관심사와 비즈니스 로직이 결합되는 지점을 결정하는 것이다.
    - 앞의 Proxy는 이 결합이 완성된 상태이므로 메서드를 호출하게 되면 자동으로 관심사가 결합된 상태로 동작하게 된다.
  - **관심사(concern)** 는 위의 그림에서 Aspect와 Advice라는 용어로 표현되어 있다.
  - **Aspect**는 조금 추상적인 개념을 의미한다.
    - 관심사 자체를 의미하는 추상명사
  - **Advice**는 Aspect를 구현한 코드이다.
  - **Advice**는 실제 걱정거리를 분리해 놓은 코드를 의미한다.
    - 동작위치에 따른 구분
    
    |구분|어노테이션|설명|
    |--|--|--|
    |Before Advice|@Before| Target의 JoinPoint를 호출하기 전에 실행되는 코드이다.</br> 코드의 실행 자체에는 관여할 수 없다.
    |After Returning Advice |@AfterReturning| 모든 실행이 정상적으로 이루어진 후 에 동작하는 코드|
    |After Throwing Advice |@AfterThrowing| 예외가 발생한 뒤에 동작하는 코드|
    |After Advice |@After| 정상적으로 실행되거나 예외가 발생했을 때 구분 없이 실행되는 코드|
    |Around Advice|@Around| 메서드의 실행 자체를 제어할 수 있는 가장 강력한 코드</br>직접 대상메서드를 호출하고 결과나 예외를 처리할 수 있다.
 - Advice는 과거의 스프링에서는 별도의 인터페이스로 구현되고, 이를 클래스로 구현하는 방식으로 제작되었으나. 스프링 3버전 이후에는 어노테이션만으로도 모든 설정이 가능하다.
 - Target에 어떤 Advice를 적용할 것인지는 XML을 이용한 설정을 이용할 수 있고, 어노테이션을 이용하는 방식을 이용할 수 있다.
 - PointCut은 Advice를 어떤 JoinPoint에 결합할 것인지를 결정하는 설정이다. AOP에서 Target은 결과적으로 PointCut에 의해서 자신에게는 없는 기능들을 가지게 된다.
 - PointCut은 다양한 형태로 선언해서 사용할 수 있는데 주로 사용되는 설정은 다음과 같다.

 |구분|설명|
 |--|---|
 |execution(@execution)| '**메서드**'를 기준으로 Pointcut을 설정한다|
 |within(@within)|특정한 '**타입(클래스)**'을 기준으로 Pointcut을 설정한다|
 |this|주어진 '**인터페이스를 구현한 객체**'를 대상으로 Pointcut을 설정한다|
 |arg(@args)|'**특정한 파라미터**'를 가지는 대상들만을 Pointcut으로 설정한다|
 |@annotation|'**특정한 어노테이션**'이 적용된 대상들만을 Pointcut으로 설정한다.|

 #### 18.1.1 용어 정리
 |구분|설명
|---|---
|Proxy|**대리인**, 함수 호출자는 주요업무가아닌 보조업무를 프록시에게 맡기고, 프록시 내부적으로 보조업무를 제어,처리
|Target| **핵심 비즈니스 로직 객체**, 부가기능을 부여할 대상
|Advice| **부가기능을 정의한 코드**, 타겟에 제공할 부가기능을 담고있는 모듈
|JoinPoint| **Advice를 적용 가능한 지점**, Spring에서 관리하는 Bean들의 모든 메서드
|pointcut| **관심사와 비즈니스 로직이 결합되는 지점을 결정하는 것**, JoinPoint의 부분집합으로도 표현
|Aspect| **Advice + pointcut**, Advice의 추상화, AOP의 기본 모듈